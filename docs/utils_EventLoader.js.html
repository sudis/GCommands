<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: utils/EventLoader.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/nav.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.3/fuse.min.js"></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link type="text/css" rel="stylesheet" href="styles/skyceil.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
</head>

<body>

<nav class="navbar">
    <div class="utilities">
        <div id="search">
            <input type="text" id="search-box" placeholder="Search"><br>
            <div id="search-results" style="display: none;"></div>
        </div>
        <button class="theme" data-theme="light"><i class="fas fa-moon"></i></button>
    </div>
    <hr>
    <h4><a href="index.html">Home</a></h4><h5 class="no-bottom must-underline">Classes</h5><ul><li><span class="small-icon C">C</span><b><a href="Color.html">Color</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="Color.html#getRGB">getRGB</a></li><li><span class="small-icon F">F</span><a href="Color.html#getText">getText</a></li><li><span class="small-icon M">M</span><a href="Color.html#text">text</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="GCommands.html">GCommands</a></b><ul class="has-class-methods"><li><span class="small-icon M">M</span><a href="GCommands.html#cmdDir">cmdDir</a></li><li><span class="small-icon M">M</span><a href="GCommands.html#cooldownDefault">cooldownDefault</a></li><li><span class="small-icon M">M</span><a href="GCommands.html#database">database</a></li><li><span class="small-icon M">M</span><a href="GCommands.html#eventDir">eventDir</a></li><li><span class="small-icon M">M</span><a href="GCommands.html#prefix">prefix</a></li><li><span class="small-icon M">M</span><a href="GCommands.html#slash">slash</a></li><li><span class="small-icon M">M</span><a href="GCommands.html#unkownCommandMessage">unkownCommandMessage</a></li></ul></li><li><span class="small-icon C">C</span><a href="GCommandsBase.html">GCommandsBase</a></li><li><span class="small-icon C">C</span><b><a href="GCommandsDispatcher.html">GCommandsDispatcher</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="GCommandsDispatcher.html#addInhibitor">addInhibitor</a></li><li><span class="small-icon F">F</span><a href="GCommandsDispatcher.html#getGuildPrefix">getGuildPrefix</a></li><li><span class="small-icon F">F</span><a href="GCommandsDispatcher.html#removeInhibitor">removeInhibitor</a></li><li><span class="small-icon F">F</span><a href="GCommandsDispatcher.html#setGuildPrefix">setGuildPrefix</a></li><li><span class="small-icon M">M</span><a href="GCommandsDispatcher.html#client">client</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="GCommandsEventLoader.html">GCommandsEventLoader</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="GCommandsEventLoader.html#createAPIMessage">createAPIMessage</a></li><li><span class="small-icon F">F</span><a href="GCommandsEventLoader.html#getSlashArgs">getSlashArgs</a></li><li><span class="small-icon F">F</span><a href="GCommandsEventLoader.html#inhibit">inhibit</a></li><li><span class="small-icon M">M</span><a href="GCommandsEventLoader.html#GCommandsClient">GCommandsClient</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="GCommandsGuild.html">GCommandsGuild</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="GCommandsGuild.html#getCommandPrefix">getCommandPrefix</a></li><li><span class="small-icon F">F</span><a href="GCommandsGuild.html#setCommandPrefix">setCommandPrefix</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="GCommandsMessage.html">GCommandsMessage</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="GCommandsMessage.html#buttons">buttons</a></li><li><span class="small-icon F">F</span><a href="GCommandsMessage.html#buttonsEdit">buttonsEdit</a></li><li><span class="small-icon F">F</span><a href="GCommandsMessage.html#buttonsWithReply">buttonsWithReply</a></li><li><span class="small-icon F">F</span><a href="GCommandsMessage.html#inlineReply">inlineReply</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="GEvents.html">GEvents</a></b><ul class="has-class-methods"><li><span class="small-icon M">M</span><a href="GEvents.html#eventDir">eventDir</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="MessageButton.html">MessageButton</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="MessageButton.html#setDisabled">setDisabled</a></li><li><span class="small-icon F">F</span><a href="MessageButton.html#setID">setID</a></li><li><span class="small-icon F">F</span><a href="MessageButton.html#setLabel">setLabel</a></li><li><span class="small-icon F">F</span><a href="MessageButton.html#setStyle">setStyle</a></li><li><span class="small-icon F">F</span><a href="MessageButton.html#setURL">setURL</a></li></ul></li></ul><h5 class="no-bottom must-underline">Events</h5><ul><li><span class="small-icon E">E</span><a href="GCommands.html#event:debug">debug</a></li></ul><h4>Global</h4><ul><li><a href="global.html#ReturnSystem">ReturnSystem</a></li></ul>
</nav>

<div id="main">
    <div class="burger">
        <div class="burger-line-1"></div>
        <div class="burger-line-2"></div>
        <div class="burger-line-3"></div>
    </div>

    <h1 class="page-title">Source: utils/EventLoader.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const {Collection,MessageEmbed,APIMessage} = require("discord.js");
const Color = require("./color/Color");
const {Events} = require("./Constants")

/**
 * The GCommandsEventLoader class
*/
class GCommandsEventLoader {

    /**
     * Creates new GCommandsEventLoader instance
     * @param {GCommandsClient} GCommandsClient
     */
    constructor(GCommandsClient) {
        /**
         * GCommandsEventLoader options
         * @property {Object} GCommandsClient
        */
        this.GCommandsClient = GCommandsClient;
        this.client = GCommandsClient.client;

        this.client.cooldowns = new Collection();

        this.messageEvent()
        this.slashEvent()
        this.loadMoreEvents()
    }

    /**
     * Internal method to messageEvent
     * @returns {void}
     * @private
    */
    async messageEvent() {
        if((this.client.slash == false) || (this.client.slash == "both")) {
            this.client.on('message', async(message) => {
                if (message.author.bot) return;
                if (!message.guild) return;
                var mentionRegex = new RegExp(`^&lt;@!?(${this.client.user.id})> `)
                var prefix = message.content.match(mentionRegex) ? message.content.match(mentionRegex)[0] : this.client.prefix

                if(this.client.database.working) {
                    var guildSettings = await this.client.dispatcher.getGuildPrefix(message.guild.id)
                    prefix = message.content.match(mentionRegex) ? message.content.match(mentionRegex)[0] : guildSettings
                }

                if (!message.content.startsWith(prefix)) return;
            
                const args = message.content.slice(prefix.length).trim().split(/ +/g);
                const cmd = args.shift().toLowerCase();
                
                if (cmd.length === 0) return;
        
                try {
                    var commandos = this.client.commands.get(cmd);
                    if(!commandos) commandos = this.client.commands.get(this.client.aliases.get(cmd));

                    var inhibit = await this.inhibit(commandos, undefined, message)
                    if(inhibit == false) return;

                    if (!this.client.cooldowns.has(commandos.name)) {
                        this.client.cooldowns.set(commandos.name, new Collection());
                    }
                    
                    const now = Date.now();
                    const timestamps = this.client.cooldowns.get(commandos.name);
                    const cooldownAmount = (commandos.cooldown ? commandos.cooldown : this.client.cooldownDefault) * 1000;
                    
                    if (timestamps.has(message.author.id)) {
                        if (timestamps.has(message.author.id)) {
                            const expirationTime = timestamps.get(message.author.id) + cooldownAmount;
                        
                            if (now &lt; expirationTime) {
                                const timeLeft = (expirationTime - now) / 1000;

                                return message.channel.send(this.client.languageFile.COOLDOWN[this.client.language].replace(/{COOLDOWN}/g, timeLeft.toFixed(1)).replace(/{CMDNAME}/g, commandos.name))
                            }
                        }
                    }

                    timestamps.set(message.author.id, now);
                    setTimeout(() => timestamps.delete(message.author.id), cooldownAmount);

                    if(commandos.guildOnly) {
                        if(message.guild.id != commandos.guildOnly) {
                            return;
                        }
                    } 

                    if(commandos.userOnly) {
                        if(typeof commandos.userOnly == "object") {
                            var users = commandos.userOnly.some(v => message.author.id == v)
                            if(!users) {
                                return
                            }
                        } else {
                            if(message.author.id != commandos.userOnly) {
                                return;
                            }
                        }
                    }

                    if(commandos.channelOnly) {
                        if(typeof commandos.channelOnly == "object") {
                            var users = commandos.channelOnly.some(v => message.channel.id == v)
                            if(!users) {
                                return
                            }
                        } else {
                            if(message.channel.id != commandos.channelOnly) {
                                return;
                            }
                        }
                    }

                    if(commandos.userRequiredPermissions) {
                        if(typeof commandos.userRequiredPermissions == "object") {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!message.member.hasPermission(commandos.userRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", ")))
                                    return;
                                }
                            } else {
                                if(!message.member.permission.has(commandos.userRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", ")))
                                    return;
                                }
                            } 
                        } else {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!message.member.hasPermission(commandos.userRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions))
                                    return;
                                }
                            } else {
                                if(!message.member.permission.has(commandos.userRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions))
                                    return;
                                }
                            } 
                        }
                    }

                    if(commandos.clientRequiredPermissions) {
                        if(typeof commandos.clientRequiredPermissions == "object") {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!message.guild.me.hasPermission(commandos.clientRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", ")))
                                    return;
                                }
                            } else {
                                if(!message.guild.me.has(commandos.clientRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", ")))
                                    return;
                                }
                            } 
                        } else {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!message.guild.me.hasPermission(commandos.clientRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions))
                                    return;
                                }
                            } else {
                                if(!message.guild.me.has(commandos.clientRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions))
                                    return;
                                }
                            } 
                        }
                    }

                    if(commandos.userRequiredRole) {
                        if(!message.member._roles.includes(commandos.userRequiredRole)) {
                            message.channel.send(this.client.languageFile.MISSING_ROLES[this.client.language].replace("{ROLES}",commandos.userRequiredRole))
                            return;
                        }
                    }

                    const client = this.client, member = message.member, guild = message.guild, channel = message.channel
                    var msg = "";
                    commandos.run({
                        client, message, member, guild, channel,
                        respond: async(options = undefined) => {
                            if(typeof options == "object") {
                                msg = await message.buttonsWithReply(options.content, options)
                            } else msg = await message.inlineReply(options)
                        },
                        edit: async(options = undefined) => {
                            if(typeof options == "object") {
                                msg = await message.buttonsEdit(msg.id, options.content, options)
                            } else msg.edit(options)
                        }
                    }, args)

                    this.GCommandsClient.emit(Events.DEBUG, new Color("&amp;d[GCommands Debug] &amp;3User &amp;a" + message.author.id + "&amp;3 used &amp;a" + cmd).getText())
                } catch(e) {
                    try {
                        commandos.run(this.client, undefined, message, args)
                    } catch(e) {
                        if(!this.GCommandsClient.unkownCommandMessage) return;
                        this.GCommandsClient.emit(Events.DEBUG, new Color("&amp;d[GCommands Debug] &amp;3" + e).getText())
                        if(this.client.languageFile.UNKNOWN_COMMAND[this.client.language]) {
                            message.channel.send(this.client.languageFile.UNKNOWN_COMMAND[this.client.language].replace("{COMMAND}",cmd));
                        }
                    }
                }
            })

            this.client.on('messageUpdate', async(oldMessage, message) => {
                if (message.author.bot) return;
                if (!message.guild) return;
                var mentionRegex = new RegExp(`^&lt;@!?(${this.client.user.id})> `)
                var prefix = message.content.match(mentionRegex) ? message.content.match(mentionRegex)[0] : this.client.prefix

                if(this.client.database.working) {
                    var guildSettings = await this.client.dispatcher.getGuildPrefix(message.guild.id)
                    prefix = message.content.match(mentionRegex) ? message.content.match(mentionRegex)[0] : guildSettings
                }

                if (!message.content.startsWith(prefix)) return;
            
                const args = message.content.slice(prefix.length).trim().split(/ +/g);
                const cmd = args.shift().toLowerCase();
                
                if (cmd.length === 0) return;
        
                try {
                    var commandos = this.client.commands.get(cmd);
                    if(!commandos) commandos = this.client.commands.get(this.client.aliases.get(cmd));

                    var inhibit = await this.inhibit(commandos, undefined, message)
                    if(inhibit == false) return;

                    if (!this.client.cooldowns.has(commandos.name)) {
                        this.client.cooldowns.set(commandos.name, new Collection());
                    }
                    
                    const now = Date.now();
                    const timestamps = this.client.cooldowns.get(commandos.name);
                    const cooldownAmount = (commandos.cooldown ? commandos.cooldown : this.client.cooldownDefault) * 1000;
                    
                    if (timestamps.has(message.author.id)) {
                        if (timestamps.has(message.author.id)) {
                            const expirationTime = timestamps.get(message.author.id) + cooldownAmount;
                        
                            if (now &lt; expirationTime) {
                                const timeLeft = (expirationTime - now) / 1000;

                                return message.channel.send(this.client.languageFile.COOLDOWN[this.client.language].replace(/{COOLDOWN}/g, timeLeft.toFixed(1)).replace(/{CMDNAME}/g, commandos.name))
                            }
                        }
                    }

                    timestamps.set(message.author.id, now);
                    setTimeout(() => timestamps.delete(message.author.id), cooldownAmount);

                    if(commandos.guildOnly) {
                        if(message.guild.id != commandos.guildOnly) {
                            return;
                        }
                    } 

                    if(commandos.userOnly) {
                        if(typeof commandos.userOnly == "object") {
                            var users = commandos.userOnly.some(v => message.author.id == v)
                            if(!users) {
                                return
                            }
                        } else {
                            if(message.author.id != commandos.userOnly) {
                                return;
                            }
                        }
                    }

                    if(commandos.channelOnly) {
                        if(typeof commandos.channelOnly == "object") {
                            var users = commandos.channelOnly.some(v => message.channel.id == v)
                            if(!users) {
                                return
                            }
                        } else {
                            if(message.channel.id != commandos.channelOnly) {
                                return;
                            }
                        }
                    }

                    if(commandos.userRequiredPermissions) {
                        if(typeof commandos.userRequiredPermissions == "object") {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!message.member.hasPermission(commandos.userRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", ")))
                                    return;
                                }
                            } else {
                                if(!message.member.permission.has(commandos.userRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", ")))
                                    return;
                                }
                            } 
                        } else {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!message.member.hasPermission(commandos.userRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions))
                                    return;
                                }
                            } else {
                                if(!message.member.permission.has(commandos.userRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions))
                                    return;
                                }
                            } 
                        }
                    }

                    if(commandos.clientRequiredPermissions) {
                        if(typeof commandos.clientRequiredPermissions == "object") {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!message.guild.me.hasPermission(commandos.clientRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", ")))
                                    return;
                                }
                            } else {
                                if(!message.guild.me.has(commandos.clientRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", ")))
                                    return;
                                }
                            } 
                        } else {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!message.guild.me.hasPermission(commandos.clientRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions))
                                    return;
                                }
                            } else {
                                if(!message.guild.me.has(commandos.clientRequiredPermissions)) {
                                    message.channel.send(this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions))
                                    return;
                                }
                            } 
                        }
                    }

                    if(commandos.requiredRole) {
                        if(!message.member._roles.includes(commandos.requiredRole)) {
                            message.channel.send(this.client.languageFile.MISSING_ROLES[this.client.language].replace("{ROLES}",commandos.requiredRole))
                            return;
                        }
                    }

                    const client = this.client, member = message.member, guild = message.guild, channel = message.channel
                    var msg = "";
                    commandos.run({
                        client, message, member, guild, channel,
                        respond: async(content) => {
                            msg = await message.inlineReply(content)
                        },
                        edit: async(content) => {
                            msg.edit(content)
                        }
                    }, args)

                    this.GCommandsClient.emit(Events.DEBUG, new Color("&amp;d[GCommands Debug] &amp;3User &amp;a" + message.author.id + "&amp;3 used &amp;a" + cmd).getText())
                } catch(e) {
                    try {
                        commandos.run(this.client, undefined, message, args)
                    } catch(e) {
                        if(!this.GCommandsClient.unkownCommandMessage) return;
                        this.GCommandsClient.emit(Events.DEBUG, new Color("&amp;d[GCommands Debug] &amp;3" + e).getText())
                        if(this.client.languageFile.UNKNOWN_COMMAND[this.client.language]) {
                            message.channel.send(this.client.languageFile.UNKNOWN_COMMAND[this.client.language].replace("{COMMAND}",cmd));
                        }
                    }
                }
            })
        }
    }

    /**
     * Internal method to slashEvent
     * @returns {void}
     * @private
    */
    async slashEvent() {
        if((this.client.slash) || (this.client.slash == "both")) {
            this.client.ws.on('INTERACTION_CREATE', async (interaction) => {
                try {
                    var commandos = this.client.commands.get(interaction.data.name);
                    if (!this.client.cooldowns.has(commandos.name)) {
                        this.client.cooldowns.set(commandos.name, new Collection());
                    }

                    var inhibit = await this.inhibit(commandos, interaction, undefined)
                    if(inhibit == false) return;

                    const now = Date.now();
                    const timestamps = this.client.cooldowns.get(commandos.name);
                    const cooldownAmount = (commandos.cooldown ? commandos.cooldown : this.client.cooldownDefault) * 1000;
                    
                    if (timestamps.has(interaction.member.user.id)) {
                        if (timestamps.has(interaction.member.user.id)) {
                            const expirationTime = timestamps.get(interaction.member.user.id) + cooldownAmount;
                        
                            if (now &lt; expirationTime) {
                                const timeLeft = (expirationTime - now) / 1000;
                                client.api.interactions(interaction.id, interaction.token).callback.post({
                                    data: {
                                        type: 4,
                                        data: {
                                            flags: 64,
                                            content: this.client.languageFile.COOLDOWN[this.client.language].replace(/{COOLDOWN}/g, timeLeft.toFixed(1)).replace(/{CMDNAME}/g, commandos.name)
                                        }
                                    }
                                });
                                return;
                            }
                        }
                    }

                    timestamps.set(interaction.member.user.id, now);
                    setTimeout(() => timestamps.delete(interaction.member.user.id), cooldownAmount);

                    if(commandos.userOnly) {
                        if(typeof commandos.userOnly == "object") {
                            var users = commandos.userOnly.some(v => interaction.member.user.id == v)
                            if(!users) {
                                return;
                            }
                        } else {
                            if(interaction.member.user.id != commandos.userOnly) {
                                return;
                            }
                        }
                    }

                    if(commandos.channelOnly) {
                        if(typeof commandos.channelOnly == "object") {
                            var users = commandos.channelOnly.some(v => interaction.channel_id == v)
                            if(!users) {
                                return;
                            }
                        } else {
                            if(interaction.channel_id != commandos.channelOnly) {
                                return;
                            }
                        }
                    }

                    if(commandos.userRequiredPermissions) {
                        if(typeof commandos.userRequiredPermissions == "object") {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!this.client.guilds.cache.get(interaction.guild_id).members.cache.get(interaction.member.user.id).hasPermission(commandos.userRequiredPermissions)) {
                                    this.client.api.interactions(interaction.id, interaction.token).callback.post({
                                        data: {
                                            type: 4,
                                            data: {
                                                flags: 64,
                                                content:  this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", "))
                                            }
                                        }
                                    });
                                    return;
                                }
                            } else {
                                if(!this.client.guilds.cache.get(interaction.guild_id).members.cache.get(interaction.member.user.id).permission.has(commandos.userRequiredPermissions)) {
                                    this.client.api.interactions(interaction.id, interaction.token).callback.post({
                                        data: {
                                            type: 4,
                                            data: {
                                                flags: 64,
                                                content: this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", "))
                                            }
                                        }
                                    });
                                    return;
                                } 
                            }
                        } else {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!this.client.guilds.cache.get(interaction.guild_id).members.cache.get(interaction.member.user.id).hasPermission(commandos.userRequiredPermissions)) {
                                    this.client.api.interactions(interaction.id, interaction.token).callback.post({
                                        data: {
                                            type: 4,
                                            data: {
                                                flags: 64,
                                                content:  this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions)
                                            }
                                        }
                                    });
                                    return;
                                }
                            } else {
                                if(!this.client.guilds.cache.get(interaction.guild_id).members.cache.get(interaction.member.user.id).permission.has(commandos.userRequiredPermissions)) {
                                    this.client.api.interactions(interaction.id, interaction.token).callback.post({
                                        data: {
                                            type: 4,
                                            data: {
                                                flags: 64,
                                                content: this.client.languageFile.MISSING_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.userRequiredPermissions)
                                            }
                                        }
                                    });
                                    return;
                                } 
                            }
                        }
                    }

                    if(commandos.clientRequiredPermissions) {
                        if(typeof commandos.clientRequiredPermissions == "object") {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!this.client.guilds.cache.get(interaction.guild_id).me.hasPermission(commandos.clientRequiredPermissions)) {
                                    this.client.api.interactions(interaction.id, interaction.token).callback.post({
                                        data: {
                                            type: 4,
                                            data: {
                                                flags: 64,
                                                content:  this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", "))
                                            }
                                        }
                                    });
                                    return;
                                }
                            } else {
                                if(!this.client.guilds.cache.get(interaction.guild_id).me.permission.has(commandos.clientRequiredPermissions)) {
                                    this.client.api.interactions(interaction.id, interaction.token).callback.post({
                                        data: {
                                            type: 4,
                                            data: {
                                                flags: 64,
                                                content: this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions.map(v => v.split(" ").map(vv => vv[0].toUpperCase() + vv.slice(1).toLowerCase()).join(" ")).join(", "))
                                            }
                                        }
                                    });
                                    return;
                                } 
                            }
                        } else {
                            if(this.client.discordjsversion.includes("12.")) {
                                if(!this.client.guilds.cache.get(interaction.guild_id).me.hasPermission(commandos.clientRequiredPermissions)) {
                                    this.client.api.interactions(interaction.id, interaction.token).callback.post({
                                        data: {
                                            type: 4,
                                            data: {
                                                flags: 64,
                                                content:  this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions)
                                            }
                                        }
                                    });
                                    return;
                                }
                            } else {
                                if(!this.client.guilds.cache.get(interaction.guild_id).me.permission.has(commandos.clientRequiredPermissions)) {
                                    this.client.api.interactions(interaction.id, interaction.token).callback.post({
                                        data: {
                                            type: 4,
                                            data: {
                                                flags: 64,
                                                content: this.client.languageFile.MISSING_CLIENT_PERMISSIONS[this.client.language].replace("{PERMISSION}",commandos.clientRequiredPermissions)
                                            }
                                        }
                                    });
                                    return;
                                } 
                            }
                        }
                    }

                    if(commandos.userRequiredRole) {
                        if(!interaction.member.roles.includes(commandos.userRequiredRole)) {
                            this.client.api.interactions(interaction.id, interaction.token).callback.post({
                                data: {
                                    type: 4,
                                    data: {
                                        flags: 64,
                                        content: this.client.languageFile.MISSING_ROLES[this.client.language].replace("{ROLES}",commandos.userRequiredRole)
                                    }
                                }
                            }); 
                            return;
                        }
                    }

                    try {

                        /**
                         * Return system for slash
                         * @name ReturnSystem
                         * @param {DiscordClient} client
                         * @param {Object} interaction
                         * @example 
                         *  return {
                         *      content: "hi",
                         *      ephemeral: true,
                         *      allowedMentions: { parse: [], repliedUser: true }
                         *  }
                         */

                        const client = this.client, member = this.client.guilds.cache.get(interaction.guild_id).members.cache.get(interaction.member.user.id);
                        commandos.run({
                            client, interaction, member,
                            guild: member.guild, 
                            channel: member.guild.channels.cache.get(interaction.channel_id),
                            respond: async(result) => {
                                var data = {
                                    content: result
                                }

                                if (typeof result === 'object') {
                                    if(typeof result == "object" &amp;&amp; !result.content) {
                                        const embed = new MessageEmbed(result)
                                        data = await this.createAPIMessage(interaction, embed)
                                    }
                                    else if(typeof result.content == "object" ) {
                                        const embed = new MessageEmbed(result.content)
                                        data = await this.createAPIMessage(interaction, embed)
                                    } else data = { content: result.content }
                                }

                                if(typeof result == "object" &amp;&amp; result.allowedMentions) { data.allowedMentions = result.allowedMentions } else data.allowedMentions = { parse: [], repliedUser: true }
                                if(typeof result == "object" &amp;&amp; result.ephemeral) { data.flags = 64 }
                                if(typeof result == "object" &amp;&amp; result.components) { data.components = [{type: 1, components: result.components}] }

                                return this.client.api.interactions(interaction.id, interaction.token).callback.post({ data: { type: 4, data }, })
                            },
                            edit: async(content) => {
                                if (typeof content === 'object') {
                                    return console.log(new Color("&amp;d[GCommands] &amp;eEdit doesn't support embed!"))
                                }

                                return this.client.api.webhooks(client.user.id, interaction.token).messages["@original"].patch({ data: { content }})
                            }
                        }, await this.getSlashArgs(interaction.data.options || []))
                    } catch(e) {
                        try {
                            var result = await commandos.run(this.client, interaction, undefined, await this.getSlashArgs(interaction.data.options || []));
                            var data = {
                                content: result
                            }
    
                            if (typeof result === 'object') {
                                if(typeof result == "object" &amp;&amp; !result.content) {
                                    const embed = new MessageEmbed(result)
                                    data = await this.createAPIMessage(interaction, embed)
                                }
                                else if(typeof result.content == "object" ) {
                                    const embed = new MessageEmbed(result.content)
                                    data = await this.createAPIMessage(interaction, embed)
                                } else {
                                    data = {
                                        content: result.content
                                    }
                                }
                            }
    
                            if(typeof result == "object" &amp;&amp; result.allowedMentions) {
                                data.allowedMentions = result.allowedMentions
                            } else {
                                data.allowedMentions = { parse: [], repliedUser: true }
                            }
    
                            if(typeof result == "object" &amp;&amp; result.ephemeral) {
                                data.flags = 64
                            }
    
                            this.client.api.interactions(interaction.id, interaction.token).callback.post({
                              data: {
                                type: 4,
                                data
                              },
                            })
                        } catch(e) {
                            this.GCommandsClient.emit(Events.DEBUG, new Color("&amp;d[GCommands Debug] &amp;3" + e).getText())
                            commandos.run(this.client, interaction);
                        }
                    }
                    
                    this.GCommandsClient.emit(Events.DEBUG, new Color("&amp;d[GCommands Debug] &amp;3User &amp;a" + interaction.member.user.id + "&amp;3 used &amp;a" + interaction.data.name).getText())
                }catch(e) {
                    if(!this.unkownCommandMessage) return;
                    this.GCommandsClient.emit(Events.DEBUG, new Color("&amp;d[GCommands Debug] &amp;3" + e).getText())
                    if(this.client.languageFile.UNKNOWN_COMMAND[this.client.language]) {
                        this.client.api.interactions(interaction.id, interaction.token).callback.post({
                            data: {
                                type: 4,
                                data: {
                                    content: this.client.languageFile.UNKNOWN_COMMAND[this.client.language].replace("{COMMAND}",interaction.data.name)
                                }
                            }
                        });
                    }
                }
            })
        }
    }

    /**
     * Internal method to loadMoreEvents
     * @returns {void}
     * @private
    */
    async loadMoreEvents() {
        require("../moreEvents/channel")(this.client)
        require("../moreEvents/guild")(this.client)
        require("../moreEvents/guildmember")(this.client)
        require("../moreEvents/role")(this.client)
        require("../moreEvents/user")(this.client)
        require("../moreEvents/voiceupdate")(this.client)
    }

    /**
     * Internal method to createAPIMessage
     * @returns {object}
    */
    async createAPIMessage(interaction, content) {
        const apiMessage = await APIMessage.create(this.client.channels.resolve(interaction.channel_id), content)
        .resolveData()
        .resolveFiles();
        
        return { ...apiMessage.data, files: apiMessage.files };
    }

    /**
     * Internal method to getSlashArgs
     * @returns {object}
    */
    async getSlashArgs(options) {
        var args = {};
        for (var o of options) {
          if (o.type == 1) args[o.name] = this.getSlashArgs(o.options || []);
          else if (o.type == 2) args[o.name] = this.getSlashArgs(o.options || []); 
          else {
              args[o.name] = o.value;
          }
        }
        return args;
    }

    /**
     * Internal method to inhivit
     * @returns {object}
    */
    async inhibit(cmd, slash, message) {
		for(const inhibitor of this.client.inhibitors) {
			let inhibit = inhibitor(cmd, slash, message);
			return inhibit;
		}
		return null;
    }
}

module.exports = GCommandsEventLoader;</code></pre>
        </article>
    </section>





</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Wed May 26 2021 22:17:24 GMT+0200 (stredoeurópsky letný čas) using <a href="https://github.com/devsnowflake/jsdoc-skyceil">Skyceil Theme</a>
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>

</body>
</html>
